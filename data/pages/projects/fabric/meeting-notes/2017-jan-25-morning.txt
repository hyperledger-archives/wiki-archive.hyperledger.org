=====  Notes from Fabric Discussion 25-JAN-2017 morning  =====

notes from Sharon Cocco (weeds):

<file>
weeds [06:35] Ok Binh came by open area and a few people
congregated---> Here are some notes as a result

jyellick [06:35] Note that we also need to fix the hashing of the
data block, which is targeted to be done as a Merkle tree, but
again, unless someone is interested in maintaining the hash
chain, I'm not sure what the value of computing this hash is.

weeds [06:36] Chaincode Ednorsement policy did make it in- there
is still another 1/2 to go

[06:36]  For Chaincode REturn object - this one is in,.. and
everyone needs to rebase- this is going to change your chain
code... This guy is to return different status code on every
chaincode

[06:37]  Anchor peers is blocked because the peer needs the
handler finished which Jason Yellick has pushed some of this-- If
Jason's stuff is checked in, we can proceed

[06:38]  All peers connect to the ordering service- you need to
join the channel at bootstrap- that code has to be written,
because not all peers will get the identity channel--> Jason
Yellick owns this

jyellick [06:39] @weeds I can hopefully get this done today.

[06:39]  (Am on the hangout, but cannot hear anything)

weeds [06:39] We are almost done with the system chaincode
refactoring which will come in this AM-  Murali did that work

[06:39]  Chaincode calling chaincode is almost 1/2 way there-
Binh is debugging

[06:39]  CLI channel to create default-  barry is working on that
relative to the docker image

[06:40]  For ledger with Dave enyeart- there are change sets out
for finishing couch miscelanous items and query.. we ahve
questions on refactoring for chaincode API- he is going to get
with Murali

[06:40]  Change set on history of key values 9LEVEL DB) IS ALMOST
READY (SORRY CAPS)

[06:41]  the phantom read work done by Manish is readyy and
checked in for review and has +1 reviews from David- needs Binh
or Gari to review this.

[06:41]  One of the issues is that everyone is so busy- noone is
doing the reviews- we need help on this

[06:41]  In terms of getting couch environment into docker for
next week- Dave Enyeart talked to Barry - bmos299.. we left it
that after you get simple happy path, we will add couch to docker
compose.

rickr [06:42] @jyellick I think we will eventually need to parse
it to get the block number when monitoring what transactions have
processed.   The blocknumber will make sure we don't process this
again 1 reply Today at 06:43 View thread

weeds [06:42] For docker- we have basic path working, we are
adding sdk.. Adnan is adding the couch stuff to it

[06:42]  Barry is working with Adnan

jyellick [06:43] replied to a thread rickr 06:42 @jyellick I
think we will eventually need to parse it to get the block number
when monitoring what transactions have processed.   The
blocknumber will make sure we don't process this again
https://hyperledgerproject.slack.com/archives/fabric-dev/p1485355326001776
1 reply jyellick 06:43 rickr: You can certainly get the block
number, but I'm not sure why you need to compute the header hash?
https://hyperledgerproject.slack.com/archives/fabric-dev/p1485355392001779?thread_ts=1485355326001776&cid=C0YPYBVJM

weeds [06:43] On the finalized QSCC block tran structures- we
talked about that yesterday. I sent a draft of whta we talked
about and we will post in community on the channel- one of the
questions was get transaction by id- we trun the tran
protostructure, but header is above that, but header is
importnat.. that is transaction id, time stamp.. so we may need
to return the payload. it should be clear in the proposal for
that... Dave Enyeart to post this to get feedback from community

[06:45]  to ARtem- when we do state synch, are we calling same
api to get block from one peer to send to another peer? they are
using committer,.. but I think it does use same api.. we need to
see if it's a lower level of apis that manipulates bytes... the
lower level gets block by # and retunrs the unmarshalled block
proto... that's what synch wants to do. maybe we have to optimize
and suck the entire file over... Right now, it calls get block...
that's very inefficient. We do a lot of marshalling and
unmarshalling.. repeated.  Dave is saying we need synch that
works on serialized block then.  Artem says ok.  This is not for
immecdiate, but needs to be logged in JIRA so as not to forget
for optimization and performance (which is focus in February)

[06:47]  On the SDK- there is outstanding chainset that needs to
be approved.  we're still making progress on event support and
join chain. both are going in parallel. we are working on
initializing the MSP that is needed to send create chain request
to orderer.  All is still on going.  We are targetting event
support completion if we don't get all chain creation and chain
join-- is that ok? we will have to use CLI... that is the backup
plan .. there is a lot of moving parts for chain creation, but we
do want to get events support done.  WE haven't added the
references to ESCC or VSCC to deploy yet-- that is higher
priority it seems like.. this is so application can execute.

[06:47]  For event support- i merged chainset that Pat
implemented

new messages [06:50]  What is ESCC /VSCC is needed? this is
absolutely needed for endorsement. Has something changed?  There
are defaults being used.. there is an item that Murali has worked
called chaincode lifecyle and endorsement policy.   Currently
transaciton comes in, we just say ok fine... but once we have
endorsement policy which is mostly done- transaction must be
signed by John.  The work on the SDK side is adding a new field
to the proposal , identifying ESCC and VSCC by name, which is
really not significant,.. and we can add that support.. Policy
being things like 3 out of 10 sigs... We can defiintely identify
and add in there for policy or we can also default system for
this round.  Supposedly application should do preliminary
checking on responses- if it's not meeting the policy- it should
discard.  Right now, we are just sending things over where VSCC
will catch that.  I'd like to keep that as is for end of month
for alpha. Yes, sounds reasonable... we do think key to send in
ESCC, VSCC, and policy.  The CR that I talked about with
endorsement policy is out there. it's called post it notation..
end/a/b something like that. you need signature for a and b... is
that a string?

[06:50]  from application, we haven't decided from community
whether string goes all the way to the peer or deployment... or
the SDK would proto this into structure- i suspect it's going to
be at the peer for desing sake.

[06:50]  CLI we can do this already

[06:51]  Documentation- There is higher level pieces,.. maybe 7
or 8 separate higher level topics as an overview documentation
for the community. 2 that are basically done and we can complete
remainder in day or 2... and knock out the rest of the stuff with
the various people assigned.

[06:54]  we need a sample, Question is what do we show for
policy, MSP,etc,. and need some input from the community for this
first round ... We do need to probably talk about system
chaincode and the apis.. that has to probably come from Murali or
Binh at this point.  Performing a query against couchdb we do
need to include for complex queries should come from Dave Eneyart

[06:56]  When they do the docker compose for getting started- it
will have example 2 chaincode.

[06:57]  in text, you can create a channel, join a channel with
these # of peers, there is a CA set up, here is your node sdk..
do an enroll and signing cert ,.. we provide a very basic nodejs
program.. so at least people have some artifacts to give feedback
on.  text, you can create a channel, join a channel with these #
of peers, there is a CA set up, here is your node sdk.. do an
enroll and signing cert ,.. we provide a very basic nodejs
program.. so at least people have some artifacts to give feedback
on.

[06:58]  we have docker images published somewhere, the docker
compose that ties all together, and zip file with some generated
materials in generated location so people can connect to it- this
gives you network that works,.. another file that shows
application code, mpm install and run... seems like maybe that
will help get people get started next week?

[07:00]  One thing in the YAML we should remove- the fields in
security section need e removed -- all those really are not
appropriate- that security seciton is getting removed-

[07:00]  Chaincode interface chain really is a big bug-- that has
to get updated

[07:00]  someone could help that and rebase

adc [07:06] okay, @jyellick @jzhang @rickr, what I want to say is
that ASN.1 is preferable solution, I would say. We can avoid it
if necessary. If we do, let's have it properly documented

jyellick [07:16] @rickr @jzhang I'm still trying to understand
why the SDK ever needs to compute this hash

weeds [07:26] Binh had discussion with Elli and Angelo- I have a
function called check acl,. This is the chaincode calling
chaincode- before we set everything to invoke another chaincode
specification, we check the acl.. and what that means is what we
want to do is to check to see whether this transaction in
proposal the signature is valid on this channel.. so imagine that
chaincode 1 calling chaincode 2. chaincode 1 on channel 1,
chaincode 2 on channel 2, chaincode 1 is invoked by user 1... so
when proposal comes in, we verify the signature against that user
1 against the config block on channel 1... so now when chaincode
1 calls chaincode 2 on channel 2 passing along the proposal.. so
now we have to verify again the user 1 signature against the
channel 2 where chaincode 2 is on.. so this is what happens in
check acl.  but we seem in code to be missing a few pieces-

[07:28]  there is check sig from creator- message validation
go... it's a local function..  I think I can call this function,
but this function- is that it's local, so we need to change to
global. but the problem is this- it takes the information we only
have from a side proposal, which is at this point is in the
handler at this point.. the only thing we have is th eproposal,
we don't have side proposal.  I want to talk to someone who
created this- Elli, angelo, ale? do we need all of this- can we
work with proposal or side proposal to call this function?  We
can get message bytes is the side proposal is the proposal bytes
itself...

[07:28]  We either have to change our handler to pass the enitre
proposal.. versus just the proposal given by this function.

[07:29]  Is this happening on the same peer? you can assume that
the proposal has already been verified, because it's verified in
the first channel, so you don't have to verify anymore- if the
peer is malicious- it's malicious.

[07:29]  We have to assume the peer is doing the right thing-
let's assume that this user has access to channel 1 to do
something but this user does not have access to channel 2.. even
though the peer joins both channels.  So in this case you do need
this.

[07:30]  We do need to enforce the ACL on both channels-

[07:31]  that function calls from validate proposal and check
sig- creator is respect to this one chain.. is there a chain id
on that? yes... we are assumin the creator verified on channel
1.. that same creator instance can be used... so yes.. if you
have creator bytes you re fine.. so how do you check the read set
and write set- how do you know?  the read can be modified on a
different channel.  we don't do any of that except we verify tat
the user signature is verifiable on channel 2.. we need to
develop that (Angelo working on that)... ARe you saying you get
read/write set of chain? what does read/write set on 2nd chain?
how do we resolve version conflicts regardless of access control?

[07:32]  If you read the JIRA item- it's a read only and and
there is no read/write set for the called chaincode.

[07:33]  if the query is on the same chain as chaincode- you have
read/write set of the chainocde and verify vscc shcek . but on
different channel, we can ONLY do read and query only

[07:33]  there is no read set- we are not sending read set from
chain 2 inside.. the only thing proposal response has is the
read/write set is for the first call of the chain.

[07:34]  WE do have the read/write set collected on the same
channel and it's working-verified

[07:34]  but on different channel we do not want to collect the
read/write set on the 2nd channel- we only want to return the
value.

[07:35]  Now that you mention it- there is one more thing you
need to do when doing different chains-- but same logic calling-
it's going to try to include it and we need to fix that on the
2nd chain

[07:35]  From security point of view- we can check the signature-
yes?

[07:36]  the 2nd chain code is working like an oracle.. it might
be an endorser that might get a different value.. so you might
see a transaction be rejected.. yes, sdk would reject.  this has
to be calirifed to the developer.. it depends on how you
implement- if you go to oracle- give me the current value-
because endorsers might end up with different view, but security
of execution-- you do same process when proposal first came-- is
the oracle value has to be included what the endorsers endorse-
the read set... but not clear if this makes sense- it's up to the
calling chaincode if they want to... because eventually the value
is considered by calling another chainocde will effect the
outcome of the execution of that chaincode

[07:37]  if the value was idfferent, then the outcome is
different,.. and the end result of that proposal would be
different

[07:37]  there is no difference if you even have a regular call
outside the blockchain

[07:38]  how do you replay the blockchain in this case?

[07:39]  this would allow for non-determinism

[07:39]  if 3 endorsers get the same response- it will have same
simulation, endorsement will succeed and commitment will be
validated despite the chaincode is not replayable

[07:44]  you have endorsement- you send read/write set... you
signed agreeing to set of inputs and you got outputs.

[07:44]  proposal come in and you want to include external data-
you need to put it into key... you have to do that.

[07:44]  This is the same as keys we read without modifying

[07:44]  the big point is this there are rules for writing
chaincode

[07:44]  1) access only state variables on database

[07:45]  2) if you access something external and you are on your
own and you better record it somehow

[07:45]  This is true whether calling chaincode or calling
external source

[07:45]  @bmos299 please make sure in doc this is recorded
clearly point 1 and 2 up above

sandra.vrtikapa [07:48] joined #fabric-dev

sandra.vrtikapa [07:50] Currently I can only receive/access
chaincode events via block events. If I set a chaincode event in
user chaincode and that part of the code doesn't generate block
event later on I am not able to receive my chaincode event. Is
there a plan to support sending/firing chaincode events from user
chaincode independent of block events?

ghaskins [08:28] @pmullaney ^^^

pmullaney [08:39] @sandra.vrtikapa : if you set a chaincode event
in a chaincode, you will generate a block( or be included in a
block)

new messages [08:40]  if you use the upcoming eventhub in the
v1.0 api, you can just register for a chaincode event - eventhub
takes care of parsing the chaincode event from the block it
receives

[08:41]  I hope that clears the question up if not ask awaytext,
you can create a channel, join a channel with these # of peers,
there is a CA set up, here is your node sdk.. do an enroll and
signing cert ,.. we provide a very basic nodejs program.. so at
least people have some artifacts to give feedback on.

[06:58]  we have docker images published somewhere, the docker
compose that ties all together, and zip file with some generated
materials in generated location so people can connect to it- this
gives you network that works,.. another file that shows
application code, mpm install and run... seems like maybe that
will help get people get started next week?

[07:00]  One thing in the YAML we should remove- the fields in
security section need e removed -- all those really are not
appropriate- that security seciton is getting removed-

[07:00]  Chaincode interface chain really is a big bug-- that has
to get updated

[07:00]  someone could help that and rebase

adc [07:06] okay, @jyellick @jzhang @rickr, what I want to say is
that ASN.1 is preferable solution, I would say. We can avoid it
if necessary. If we do, let's have it properly documented

jyellick [07:16] @rickr @jzhang I'm still trying to understand
why the SDK ever needs to compute this hash

weeds [07:26] Binh had discussion with Elli and Angelo- I have a
function called check acl,. This is the chaincode calling
chaincode- before we set everything to invoke another chaincode
specification, we check the acl.. and what that means is what we
want to do is to check to see whether this transaction in
proposal the signature is valid on this channel.. so imagine that
chaincode 1 calling chaincode 2. chaincode 1 on channel 1,
chaincode 2 on channel 2, chaincode 1 is invoked by user 1... so
when proposal comes in, we verify the signature against that user
1 against the config block on channel 1... so now when chaincode
1 calls chaincode 2 on channel 2 passing along the proposal.. so
now we have to verify again the user 1 signature against the
channel 2 where chaincode 2 is on.. so this is what happens in
check acl.  but we seem in code to be missing a few pieces-

[07:28]  there is check sig from creator- message validation
go... it's a local function..  I think I can call this function,
but this function- is that it's local, so we need to change to
global. but the problem is this- it takes the information we only
have from a side proposal, which is at this point is in the
handler at this point.. the only thing we have is th eproposal,
we don't have side proposal.  I want to talk to someone who
created this- Elli, angelo, ale? do we need all of this- can we
work with proposal or side proposal to call this function?  We
can get message bytes is the side proposal is the proposal bytes
itself...

[07:28]  We either have to change our handler to pass the enitre
proposal.. versus just the proposal given by this function.

[07:29]  Is this happening on the same peer? you can assume that
the proposal has already been verified, because it's verified in
the first channel, so you don't have to verify anymore- if the
peer is malicious- it's malicious.

[07:29]  We have to assume the peer is doing the right thing-
let's assume that this user has access to channel 1 to do
something but this user does not have access to channel 2.. even
though the peer joins both channels.  So in this case you do need
this.

[07:30]  We do need to enforce the ACL on both channels-

[07:31]  that function calls from validate proposal and check
sig- creator is respect to this one chain.. is there a chain id
on that? yes... we are assumin the creator verified on channel
1.. that same creator instance can be used... so yes.. if you
have creator bytes you re fine.. so how do you check the read set
and write set- how do you know?  the read can be modified on a
different channel.  we don't do any of that except we verify tat
the user signature is verifiable on channel 2.. we need to
develop that (Angelo working on that)... ARe you saying you get
read/write set of chain? what does read/write set on 2nd chain?
how do we resolve version conflicts regardless of access control?

[07:32]  If you read the JIRA item- it's a read only and and
there is no read/write set for the called chaincode.

[07:33]  if the query is on the same chain as chaincode- you have
read/write set of the chainocde and verify vscc shcek . but on
different channel, we can ONLY do read and query only

[07:33]  there is no read set- we are not sending read set from
chain 2 inside.. the only thing proposal response has is the
read/write set is for the first call of the chain.

[07:34]  WE do have the read/write set collected on the same
channel and it's working-verified

[07:34]  but on different channel we do not want to collect the
read/write set on the 2nd channel- we only want to return the
value.

[07:35]  Now that you mention it- there is one more thing you
need to do when doing different chains-- but same logic calling-
it's going to try to include it and we need to fix that on the
2nd chain

[07:35]  From security point of view- we can check the signature-
yes?

[07:36]  the 2nd chain code is working like an oracle.. it might
be an endorser that might get a different value.. so you might
see a transaction be rejected.. yes, sdk would reject.  this has
to be calirifed to the developer.. it depends on how you
implement- if you go to oracle- give me the current value-
because endorsers might end up with different view, but security
of execution-- you do same process when proposal first came-- is
the oracle value has to be included what the endorsers endorse-
the read set... but not clear if this makes sense- it's up to the
calling chaincode if they want to... because eventually the value
is considered by calling another chainocde will effect the
outcome of the execution of that chaincode

[07:37]  if the value was idfferent, then the outcome is
different,.. and the end result of that proposal would be
different

[07:37]  there is no difference if you even have a regular call
outside the blockchain

[07:38]  how do you replay the blockchain in this case?

[07:39]  this would allow for non-determinism

[07:39]  if 3 endorsers get the same response- it will have same
simulation, endorsement will succeed and commitment will be
validated despite the chaincode is not replayable

[07:44]  you have endorsement- you send read/write set... you
signed agreeing to set of inputs and you got outputs.

[07:44]  proposal come in and you want to include external data-
you need to put it into key... you have to do that.

[07:44]  This is the same as keys we read without modifying

[07:44]  the big point is this there are rules for writing
chaincode

[07:44]  1) access only state variables on database

[07:45]  2) if you access something external and you are on your
own and you better record it somehow

[07:45]  This is true whether calling chaincode or calling
external source

[07:45]  @bmos299 please make sure in doc this is recorded
clearly point 1 and 2 up above
</file>